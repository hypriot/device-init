package cmd

import (
	"fmt"
	"text/template"
	"bytes"
	"strings"
	"os"
	"path"
	"io/ioutil"
	"regexp"
	"os/exec"

	"github.com/spf13/cobra"
)

type Interface struct {
	Name           string
	Address        string
	Netmask        string
	Gateway        string
	DNSNameservers []string
	DNSSearch      string
	SSID           string
	Password       string
}

type NetworkConfig struct {
	Interfaces map[string]Interface
}

var networkCmd = &cobra.Command{
	Use:   "network",
	Short: "set network settings",
	Long:  `Set network settings.
Network configuration only possible via config file.`,
	Run: func(cmd *cobra.Command, args []string) {
		if config.IsSet("network") {
			setNetwork()
		} else {
			cmd.Help()
		}
	},
}

func setNetwork()  {
	if config.IsSet("network") {
		var networkConfig NetworkConfig
		err := config.UnmarshalKey("network", &networkConfig)
		if err != nil {
			fmt.Println("Could not unmarshal Network configuration")
		}
		configureNetwork(networkConfig)
	}
}

func configureNetwork(networkConfig NetworkConfig) {
	for interfaceName, interfaceConfig := range networkConfig.Interfaces {
		interfaceConfig.Name = interfaceName

		if interfaceConfig.Password != "" && interfaceConfig.SSID != ""{
			interfaceConfig.Password = createEncryptedPsk([]byte(interfaceConfig.Password), []byte(interfaceConfig.SSID))
		}

		interfaceString := generateInterfaceConfig(interfaceConfig)
		applyInterfaceConfig(interfaceName, interfaceString)
	}
}

func generateInterfaceConfig(interfaceConfig Interface) string {
	var interfaceString string

	const interfaceTemlate = `# interface configuration generated by device-init
allow-hotplug {{.Name}}
auto {{.Name}}
iface {{.Name}} inet {{if .Address}}static{{else}}dhcp{{end}}
  {{if .Address}}address {{.Address}}{{end}}
  {{if .Netmask}}netmask {{.Netmask}}{{end}}
  {{if .Gateway}}gateway {{.Gateway}}{{end}}
  {{if .DNSNameservers}}dns-nameservers {{range $key, $value := .DNSNameservers}}{{$value}} {{end}}{{end}}
  {{if .DNSSearch}}dns-search {{.DNSSearch}}{{end}}
  {{if .SSID}}wpa-ssid {{.SSID}}{{end}}
  {{if .Password}}wpa-psk {{.Password}}{{end}}
  {{if .Address}}pre-up ip addr flush dev {{.Name}}{{end}}
`
	t := template.Must(template.New("config").Parse(interfaceTemlate))
	var buffer bytes.Buffer
	err := t.Execute(&buffer, interfaceConfig)
	if err != nil {
		fmt.Println("Error writing configuration:", err)
	}

	interfaceString = buffer.String()
	interfaceString = strings.Replace(interfaceString, "  \n", "", -1)

	return interfaceString
}

func applyInterfaceConfig(interfaceName string, interfaceConfig string) {
	err := os.MkdirAll(networkInterfacesPath, 0755)
	if err != nil {
		fmt.Println("Could not create path: ", networkInterfacesPath)
	}

	configFilePath := path.Join(networkInterfacesPath, interfaceName)
	if _, err := os.Stat(configFilePath); err == nil {
		filepath, filename := path.Dir(configFilePath), path.Base(configFilePath)
		backupFile := "." + filename + ".backup"
		backupPath := path.Join(filepath, backupFile)
		err = os.Rename(configFilePath, backupPath)
		if err != nil {
			fmt.Println("Could not backup file ", backupPath, ": ", err)
		}
	}

	f, err := os.Create(configFilePath)
	defer f.Close()
	if err != nil {
		fmt.Println("Could not create file: "+configFilePath+": ", err)
	}

	err = ioutil.WriteFile(configFilePath, []byte(interfaceConfig), 0644)
	if err != nil {
		panic(err)
	}

	// restart an existing interface
	if interfaceExists(interfaceName) {
		output, err := exec.Command("/sbin/ifdown", interfaceName).CombinedOutput()
		if err != nil {
			message := fmt.Sprintf("Could not bring the interface down %s: %s ", interfaceName, err)
			fmt.Println(message)
		}
		fmt.Println(string(output)[:])
	}

	if interfaceExistsAndIsDown(interfaceName) {
		output, err := exec.Command("/sbin/ifup", interfaceName).CombinedOutput()
		if err != nil {
			message := fmt.Sprintf("Could not bring up interface %s: %s", interfaceName, err)
			fmt.Println(message)
		}
		fmt.Println(string(output)[:])
	}

	// try to bring the interface up once more but bring it down before
	if interfaceExistsAndIsDown(interfaceName) {
		output, err := exec.Command("/sbin/ifdown", interfaceName).CombinedOutput()
		if err != nil {
			message := fmt.Sprintf("Could not bring the interface down %s: %s ", interfaceName, err)
			fmt.Println(message)
		}
		fmt.Println(string(output)[:])
		output, err = exec.Command("/sbin/ifup", interfaceName).CombinedOutput()
		if err != nil {
			message := fmt.Sprintf("Could still not bring up interface %s: %s", interfaceName, err)
			fmt.Println(message)
		}
	}
}


func init() {
	RootCmd.AddCommand(networkCmd)
}


func interfaceExistsAndIsDown(interfaceName string) bool {
	stats := getInterfaceStats()
	for _, line := range stats {
		interfaceExists, _ := regexp.MatchString(interfaceName, line)
		interfaceIsDown, _ := regexp.MatchString("state DOWN", line)
		if interfaceExists && interfaceIsDown {
			return true
		}
	}
	return false
}


func interfaceExists(interfaceName string) bool {
	stats := getInterfaceStats()
	for _, line := range stats {
		interfaceExists, _ := regexp.MatchString(interfaceName, line)
		if interfaceExists {
			return true
		}
	}
	return false
}


func getInterfaceStats() []string {
	output, err := exec.Command("ip", "link").Output()
	if err != nil {
		fmt.Println("Could not run 'ip link'", err)
	}
	return strings.Split(string(output), "\n")
}